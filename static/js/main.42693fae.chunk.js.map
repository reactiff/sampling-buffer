{"version":3,"sources":["DataTable/Header.tsx","DataTable/TableRow.tsx","DataTable/index.tsx","../../src/Serie/index.ts","../../src/ClosedCircuitBuffer.ts","../../src/createSampler.ts","../../src/FieldGroups.ts","../../src/index.ts","../../src/SamplingBuffer.ts","App.tsx","index.tsx"],"names":["Header","props","cols","map","c","index","key","TableRow","item","isArray","Array","className","value","toFixed","Table","items","cellPadding","cellSpacing","length","itemIndex","fnMin","serie","availLength","options","elements","pos","buffer","Math","fnMax","fnMean","sum","cnt","fnCustom","callback","fnStDev","mean","sumOfSq","val","attachAggregateFn","offset","Error","fn","n","Serie","Object","this","attachCustomAggregateFn","createSerie","field","track","getOffsetAdjAvailableLength","ClosedCircuitBuffer","tags","array","cursor","counter","serieInstances","series","arrayLike","sampler","get","getIndex","createSeries","keys","fields","_instance","Proxy","target","nextSample","currentTime","current","__count","prevSlot","fillMissingSamples","normallySkippedMax","interval","missingSamples","time","elapsed","i","insertedTime","lastPeriodTime","preload","sampleTime","getSampleTime","data","shouldAdvance","capture","captureTime","lifo","limit","absOffset","requestedLmt","offsetAdjLmt","relative","ordinal","j","fifo","arrlen","lmt","parseField","fieldDict","getFields","publicKeys","hiddenKeys","expressionKeys","hidden","cumulative","fill","d","parseFieldsAsArray","parseFieldsAsDictionary","expressions","expr","createSampleFactory","sample","fnOrValue","params","createSampler","addExpression","name","expression","k","object","obj","keysToDelete","deleteKeys","t","blank","bufferLength","collect","currSlot","result","aggregateSample","calculateExpressions","createSample","cumulatives","expressionDict","ffill","newSamplePredicate","suppressAutoSampling","timeKey","trackKeys","tracks","min","max","abs","cryptoTrade","dataFields","curr","ohlc","open","p","high","low","close","side","_buy","when","_sell","volume","buyVol","sellVol","ttlVol","netVol","cumNetVol","mv","buyMv","sellMv","ttlMv","netMv","volWtdPrice","acc","stats","ttlTradeCount","buyTradeCount","sellTradeCount","defaultValue","condition","noFilter","MultiTrackBuffer","sampling","getTracks","kv","filter","startSampling","setInterval","_track","stopSampling","clearInterval","createDataTracks","trackKey","pk","valueOrDefault","rndWalk","RandomWalk","SamplingBuffer","FieldGroups","price","calcSerie","availableLength","prev","_","ema10","sma10","m","React","useRef","clickIndex","periods","tickCount","initialized","stopped","useState","columns","setColumns","fifoData","setFifoData","readTrackData","useCallback","fifos","useEffect","onTrackStart","onUpdate","onInterval","values","delayCapture","trade","exch","round","next","qty","random","simulateTradeEvent","Date","getTime","setTimeout","handleClick","onClick","style","marginBottom","DataTable","ReactDOM","render","App","document","getElementById"],"mappings":"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","file":"static/js/main.42693fae.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nconst Header = (props: any) => {\r\n    \r\n    const cols = props.cols || [];\r\n\r\n    return <thead>\r\n        <tr>\r\n            {\r\n                cols.map((c: any, index: number) => {\r\n                    return <th key={index}>{c}</th>\r\n                })\r\n            }\r\n        </tr>\r\n    </thead>\r\n}\r\n\r\nexport default Header;","import React from 'react';\r\n\r\nconst TableRow = (props: any) => {\r\n    \r\n    const item = props.item;\r\n    const cols = props.cols;\r\n\r\n    const isArray = Array.isArray(item);\r\n\r\n    return (\r\n        <tr className=\"no-text-overflow\">\r\n\r\n            {\r\n                isArray &&\r\n                item.map((value: any, index: number) => {\r\n                    return <td key={cols[index]}>\r\n                        {\r\n                            typeof value === 'number' &&\r\n                            value.toFixed(0)\r\n                        }\r\n                    </td>\r\n                })   \r\n            }\r\n\r\n            {\r\n                !isArray &&\r\n                cols.map((c: any, index: number) => {\r\n                    return <td key={cols[index]}>\r\n                        {\r\n                            typeof item[c] === 'number' &&\r\n                            item[c].toFixed(0)\r\n                        }\r\n                    </td>\r\n                })\r\n            }\r\n        </tr>\r\n    )\r\n}\r\n\r\nexport default TableRow;","import React from 'react'\r\nimport Header from './Header';\r\nimport TableRow from './TableRow';\r\nimport './style.css';\r\n\r\ntype Props = {\r\n    cols: string[],\r\n    items: any[],\r\n};\r\n\r\nconst Table = (props: Props) => {\r\n\r\n    const cols: string[] = props.cols;\r\n    const items = props.items;\r\n\r\n    if (!items) return null;\r\n\r\n    \r\n\r\n    return <table cellPadding={0} cellSpacing={0} className=\"data-table\" >\r\n        \r\n        {\r\n            cols && \r\n            cols.length > 0 &&\r\n            <Header cols={cols} />\r\n        }\r\n\r\n        <tbody>\r\n            {\r\n                items.map((item: any, itemIndex: number ) => (\r\n                    <TableRow key={itemIndex} item={item} cols={cols} />\r\n                ))\r\n            }\r\n        </tbody>\r\n    </table>\r\n    \r\n};\r\n\r\nexport default Table;\r\n","import ClosedCircuitBuffer from \"../ClosedCircuitBuffer\";\r\nimport { SerieOptions, AggregateFn1Def, AggregateFn1, CustomAggregateFnDef, CustomAggregateFn, CustomAggregateVoidCallback } from '../types';\r\n\r\n\r\nconst fnMin: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset: number) => {\r\n    const availLength = options.track.getOffsetAdjAvailableLength(offset);\r\n    if (availLength < n) return undefined;\r\n\r\n    const elements  = new Array(availLength);\r\n    options.track.lifo((pos, buffer) => {\r\n        elements[pos.ordinal] = buffer[pos.index][options.field];\r\n    }, offset, availLength)\r\n    \r\n    return Math.min(...elements);\r\n}\r\n\r\nconst fnMax: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset: number) => {\r\n    const availLength = options.track.getOffsetAdjAvailableLength(offset);\r\n    if (availLength < n) return undefined;\r\n\r\n    const elements  = new Array(availLength);\r\n    options.track.lifo((pos, buffer) => {\r\n        elements[pos.ordinal] = buffer[pos.index][options.field];\r\n    }, offset, availLength)\r\n    \r\n    return Math.max(...elements);\r\n}\r\n\r\n\r\nconst fnSum: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset: number) => {\r\n    const availLength = options.track.getOffsetAdjAvailableLength(offset);\r\n    if (availLength < n) return undefined;\r\n    \r\n    let sum = 0;\r\n    options.track.lifo((pos, buffer) => {\r\n        sum += buffer[pos.index][options.field];\r\n    }, offset, availLength)\r\n    \r\n    return sum;\r\n}\r\n\r\nconst fnMean: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset: number) => {\r\n    const availLength = options.track.getOffsetAdjAvailableLength(offset);\r\n    if (availLength < n) return undefined;\r\n    \r\n    let sum = 0;\r\n    let cnt = 0;\r\n\r\n    options.track.lifo((pos, buffer) => {\r\n        sum += buffer[pos.index][options.field];\r\n        cnt++;\r\n    }, offset, availLength)\r\n    \r\n    return sum / cnt;\r\n}\r\n\r\nconst fnCustom = (serie: Serie, options: SerieOptions, n: number, offset: number, callback: CustomAggregateVoidCallback) => {\r\n    const availLength = options.track.getOffsetAdjAvailableLength(offset);\r\n    if (availLength < n) return undefined;\r\n    options.track.lifo((pos, buffer) => {\r\n        callback(pos, buffer[pos.index][options.field])\r\n    }, offset, availLength);\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Uses Bessel's correction of bias.\r\n * @param {array} array \r\n */\r\n \r\nconst fnStDev: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset: number) => {\r\n    const availLength = options.track.getOffsetAdjAvailableLength(offset);\r\n    if (availLength === 0) return undefined;\r\n\r\n    const mean = serie.mean(n, offset)!;\r\n\r\n    let sumOfSq = 0;\r\n    let cnt = 0;\r\n    serie.fn(n, offset, (pos, val) => {\r\n        sumOfSq += (val - mean) ** 2;\r\n        cnt++;\r\n    });\r\n\r\n    return Math.sqrt(sumOfSq / cnt);\r\n}\r\n\r\nfunction attachAggregateFn(serie: Serie, options: SerieOptions, fn: AggregateFn1Def) {\r\n    return (n: number, offset = 0) => {\r\n        if (offset > 0) throw new Error('offset must be negative');\r\n        return fn(serie, options, n, offset);\r\n    };\r\n}\r\nfunction attachCustomAggregateFn(serie: Serie, options: SerieOptions, fn: CustomAggregateFnDef) {\r\n    return (n: number, offset = 0, callback: CustomAggregateVoidCallback) => {\r\n        if (offset > 0) throw new Error('offset must be negative');\r\n        return fn(serie, options, n, offset, callback);\r\n    };\r\n}\r\n\r\nexport default class Serie {\r\n    \r\n    fn:  CustomAggregateFn;\r\n    min: AggregateFn1;\r\n    max: AggregateFn1;\r\n\r\n    mean: AggregateFn1;\r\n    \r\n    stDev: AggregateFn1;\r\n\r\n    value: (offset?: number) => number | undefined;\r\n\r\n    track: ClosedCircuitBuffer;\r\n    field: string;\r\n\r\n    constructor(options: SerieOptions) {\r\n        Object.assign(this, options);\r\n\r\n        this.min = attachAggregateFn(this, options, fnMin);\r\n        this.max = attachAggregateFn(this, options, fnMax);\r\n        this.mean = attachAggregateFn(this, options, fnMean);\r\n        \r\n        this.fn  = attachCustomAggregateFn(this, options, fnCustom);\r\n\r\n        this.stDev = attachAggregateFn(this, options, fnStDev);\r\n\r\n        this.value = (offset = 0) => {\r\n            const availLength = this.track.getOffsetAdjAvailableLength(offset);\r\n            if (availLength === 0) return undefined;\r\n            return this.track.get(offset)[this.field];\r\n        }\r\n    }\r\n\r\n    get availableLength() {\r\n        const availLength = this.track.getOffsetAdjAvailableLength(0);\r\n        return availLength;\r\n    }\r\n\r\n    \r\n\r\n    static createSerie(field: string, track: ClosedCircuitBuffer) {\r\n        return new Serie({\r\n            field,\r\n            track,\r\n        });\r\n    }\r\n}","import Serie from './Serie';\r\nimport {\r\n    IteratorCallback,\r\n    IteratorPosition,\r\n    NewSamplePredicate,\r\n    Sampler,\r\n    SerieFactory,\r\n} from './types';\r\n\r\nclass ClosedCircuitBuffer {\r\n    \r\n    key: string;\r\n    tags: any = {};\r\n\r\n    array: any[] = [];\r\n    cursor: number = 0;\r\n    counter = 0;\r\n\r\n    shouldAdvance: NewSamplePredicate;\r\n\r\n    // prevSample: any;\r\n    lastPeriodTime: number;\r\n    sampler: Sampler;\r\n\r\n    onUpdate?: () => void;\r\n    lastAdvanceTime?: number;\r\n\r\n    serieInstances: any = {};\r\n    series: { [index: string]: SerieFactory } = {};\r\n\r\n    constructor(length: number, sampler: Sampler) {\r\n        const arrayLike = { length }; \r\n        this.sampler = sampler!;\r\n        this.array = Array.from(arrayLike).map(this.sampler.createSample);\r\n        this.cursor = length ? 0 : -1;\r\n        this.shouldAdvance = this.sampler.newSamplePredicate;\r\n        this.createSeries();\r\n    }\r\n    \r\n    getOffsetAdjAvailableLength(offset: number) {\r\n        return Math.max(\r\n            0,\r\n            Math.min(this.array.length, this.counter + 1) - Math.abs(offset)\r\n        );\r\n    }\r\n\r\n    get length() {\r\n        return this.array.length;\r\n    }\r\n\r\n    get current() {\r\n        return this.array[this.cursor];\r\n    }\r\n\r\n    get(offset = 0) {\r\n        return this.array[this.getIndex(offset)];\r\n    }\r\n\r\n    getIndex(offset = 0) {\r\n        let index = this.cursor + offset\r\n        if (offset > 0) {\r\n            return index  % this.array.length;\r\n        }\r\n        while (index < 0) {\r\n            index = this.array.length + index;\r\n        }\r\n        return index;\r\n    }\r\n\r\n    createSeries() {\r\n        const keys = [\r\n            ...this.sampler.fields.publicKeys,\r\n            ...this.sampler.fields.expressionKeys,\r\n        ];\r\n\r\n        this.serieInstances = {};\r\n        const series = {};\r\n\r\n        const _instance = this;\r\n        keys.forEach(key => {\r\n            series[key] = () => {\r\n                if (!_instance.serieInstances[key]) {\r\n                    _instance.serieInstances[key] = Serie.createSerie(key, _instance);\r\n                }\r\n                return _instance.serieInstances[key];\r\n            }\r\n        })\r\n\r\n        const seriesHandler = {\r\n            get: (target, prop, receiver) => {\r\n                return target[prop]();\r\n            }\r\n        };\r\n        \r\n        this.series = new Proxy(series, seriesHandler);\r\n    }\r\n    \r\n    nextSample(caller: string) {\r\n        \r\n        const currentTime = this.current[this.sampler.timeKey];\r\n        this.lastAdvanceTime = currentTime;\r\n\r\n        // see if the current slot hasn't received any data and fill forward from last slot\r\n        if (this.current.__count === 0) {    \r\n            const prevSlot = this.get(-1);\r\n            if (prevSlot.__count) {\r\n                this.sampler.ffill(this.current, prevSlot);                          \r\n            }\r\n        }  \r\n\r\n        this.counter++;\r\n        this.cursor++;\r\n        if (this.cursor === this.array.length) {\r\n            this.cursor = 0;\r\n        }\r\n        \r\n        Object.assign(this.array[this.cursor], this.sampler.blank);\r\n\r\n        this.array[this.cursor][this.sampler.timeKey] = currentTime + this.sampler.interval;\r\n    };\r\n\r\n    fillMissingSamples(time: number) {\r\n        // when loading from history, we need to account for missing data\r\n        // and insert missing samples, something that would normally\r\n        // be taken care of by the timer\r\n\r\n        let normallySkippedMax = 1;\r\n        if (this.sampler.suppressAutoSampling) {\r\n            normallySkippedMax = 0;\r\n        }\r\n\r\n        if (this.sampler.interval > 0 && this.lastPeriodTime) {\r\n            const elapsed = time - this.lastPeriodTime;\r\n            const missingSamples = elapsed / this.sampler.interval - normallySkippedMax;\r\n            if (missingSamples > 0) {\r\n                for (let i = 0; i<missingSamples; i++) {\r\n                    const offset = this.sampler.interval;\r\n                    const insertedTime = this.lastPeriodTime + offset;\r\n                    this.nextSample('fillMissingSamples');\r\n                    this.lastPeriodTime = insertedTime;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Preload buffer with history data\r\n     * @param data \r\n     */\r\n    preload(data: any) {\r\n\r\n        const sampleTime = this.sampler.getSampleTime(data.time);\r\n        \r\n        this.fillMissingSamples(sampleTime)\r\n\r\n        this.sampler.collect(this, this.current, data, sampleTime);\r\n        \r\n        if (this.shouldAdvance(this.current, data, sampleTime, this.lastPeriodTime)) {\r\n            this.nextSample('preload'); \r\n            this.lastPeriodTime = sampleTime;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Record real-time data from a stream\r\n     * @param data \r\n     * @returns \r\n     */\r\n    capture(data: any, time?: number) {\r\n        const captureTime = time || data[this.sampler.timeKey];\r\n        const sampleTime = this.sampler.getSampleTime(captureTime);\r\n\r\n        if (!this.lastPeriodTime) {\r\n            this.lastPeriodTime = sampleTime;\r\n        }\r\n        // if any samples were skipped, fill them before capturing\r\n        if (this.sampler.interval > 0 && this.sampler.suppressAutoSampling) {\r\n            this.fillMissingSamples(sampleTime);\r\n        }\r\n\r\n        this.sampler.collect(this, this.current, data, sampleTime);\r\n\r\n        if (this.sampler.interval === 0) {\r\n            this.nextSample('capture'); \r\n            this.lastPeriodTime = sampleTime;\r\n        }\r\n        \r\n        this.onUpdate && this.onUpdate();\r\n    }\r\n    \r\n    lifo(callback: IteratorCallback, offset: number, limit = -1) {\r\n        const absOffset     = Math.abs(offset || 0);\r\n        const requestedLmt  = limit >= 0 ? Math.abs(limit) : 0;\r\n        const offsetAdjLmt  = this.array.length - absOffset;\r\n        \r\n        const pos: IteratorPosition = {\r\n            index: this.cursor - absOffset, // starting position (adjusted for offset)\r\n            relative: 0,                    \r\n            ordinal: 0,                     // zero based iteration number\r\n        };\r\n\r\n        let j   = this.array.length;\r\n        while (j--) {\r\n\r\n            if (absOffset  && pos.ordinal >= offsetAdjLmt) {\r\n                break;\r\n            }\r\n            if (limit >= 0 && pos.ordinal >= requestedLmt) {\r\n                break;\r\n            }\r\n\r\n            // loop around\r\n            if (pos.index < 0) {\r\n                pos.index = this.array.length - 1; \r\n            }\r\n\r\n            callback(\r\n                pos,\r\n                this.array\r\n            );\r\n\r\n            pos.ordinal++;\r\n            pos.index--;\r\n            pos.relative--;\r\n        }\r\n    }\r\n\r\n    fifo(callback: IteratorCallback, limit = -1) {\r\n        const arrlen = this.array.length;\r\n        let lmt = limit >= 0 ? limit : arrlen;\r\n\r\n        const pos: IteratorPosition = {\r\n            index: 0,                   \r\n            relative: -(arrlen - 1),                    \r\n            ordinal: 0,                 \r\n        };\r\n\r\n        let j = arrlen;\r\n        let i = 0;\r\n        while (j-- && lmt--) {\r\n            pos.index = (arrlen + this.cursor - j) % arrlen;\r\n\r\n            callback(\r\n                pos,\r\n                this.array\r\n            );\r\n\r\n            pos.ordinal++;\r\n            pos.relative++;\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n}\r\n\r\nexport default ClosedCircuitBuffer;","import ClosedCircuitBuffer from \"./ClosedCircuitBuffer\";\r\n\r\nimport Serie from \"./Serie\";\r\nimport { Sampler, SamplerOptions, FieldDict, Expression, SampleFieldDictEntry, SampleFieldArrayItem } from \"./types\";\r\n\r\nfunction deleteKeys(object: any, keysToDelete: string[]) {\r\n    const obj: any = {...object};\r\n    keysToDelete.forEach(key => delete obj[key]);\r\n    return obj;\r\n}\r\n\r\nfunction parseField(fieldDict: FieldDict, key: string, value: any) {\r\n\r\n    fieldDict.keys.push(key);\r\n    \r\n    // hidden\r\n    if (key[0] === '_' && key[1] !== '_') {\r\n        fieldDict.hidden[key] = true;\r\n        fieldDict.hiddenKeys.push(key);\r\n    } else {\r\n        fieldDict.publicKeys.push(key);\r\n    }\r\n\r\n    if (typeof value === 'function') {\r\n        fieldDict.fn[key] = value;\r\n    } \r\n    else if (typeof value === 'object') {\r\n        if (!!value.cumulative) {\r\n            fieldDict.cumulative[key] = true;\r\n        }\r\n        fieldDict.fn[key] = value.fn;\r\n        fieldDict.fill[key] = value.fill;\r\n    } \r\n    else { // number\r\n        fieldDict.fn[key] = () => value;\r\n    }\r\n}\r\n\r\nfunction parseFieldsAsArray(fieldDict: FieldDict, options: SamplerOptions) {\r\n    const fields = options.fields as SampleFieldArrayItem[];\r\n    fields.forEach(field => {\r\n        switch (typeof field) {\r\n            case 'string':\r\n                parseField(fieldDict, field, d => d[field] )\r\n                break;\r\n            default: // must be of type SampleFieldNamed\r\n                parseField(fieldDict, field.name, field)\r\n                break;\r\n        }\r\n    });\r\n}\r\n\r\nfunction parseFieldsAsDictionary(fieldDict: FieldDict, options: SamplerOptions) {\r\n    Object.entries(options.fields).forEach(([key, value]) => {\r\n        parseField(fieldDict, key, value);\r\n    });\r\n}\r\n\r\nfunction getFields(options: SamplerOptions, expressions: any[]) {\r\n    const fieldDict: FieldDict = {\r\n        keys: [],\r\n        publicKeys: [],\r\n        hiddenKeys: [],\r\n        expressionKeys: [],\r\n        hidden: {},\r\n        cumulative: {},\r\n        fn: {},\r\n        fill: {},\r\n    };\r\n\r\n    if (Array.isArray(options.fields)) {\r\n        parseFieldsAsArray(fieldDict, options);\r\n    } else {\r\n        parseFieldsAsDictionary(fieldDict, options);\r\n    }\r\n\r\n    expressions.forEach((expr: any) => {\r\n        fieldDict.expressionKeys.push(expr.name);\r\n    });\r\n\r\n    return fieldDict;\r\n}\r\n\r\nfunction createSampleFactory(fields: FieldDict) {\r\n    const sample = { __count: 0 };\r\n    fields.publicKeys.forEach(key => {\r\n        sample[key] = undefined;\r\n    });\r\n    fields.expressionKeys.forEach(key => {\r\n        sample[key] = undefined;\r\n    });\r\n    return () => ({ ...sample });\r\n}\r\n\r\nconst fnOrValue = (value: any, ...params: any[]) => {\r\n    if (typeof value === 'function') return value(...params);\r\n    return value;\r\n}\r\n\r\nexport function createSampler(options: SamplerOptions) {\r\n\r\n    const fields = getFields(options, []);\r\n\r\n    const sampler: Sampler = {\r\n        addExpression,          // hoisted funciton\r\n        blank:                  {},\r\n        bufferLength:           options.bufferLength,\r\n        collect,                // hoisted funciton\r\n        createSample:           createSampleFactory(fields),\r\n        cumulatives:            [],\r\n        expressionDict:         {},\r\n        expressions:            [],\r\n        ffill,                  // hoisted funciton\r\n        fields,\r\n        getSampleTime,          // hoisted funciton\r\n        interval:               options.interval || 0,\r\n        newSamplePredicate,     // hoisted funciton\r\n        series:                 {},\r\n        suppressAutoSampling:   options.suppressAutoSampling,\r\n        timeKey:                fnOrValue(options.timeKey)  || 'time',\r\n        trackKeys:              options.trackKeys || [],\r\n        tracks:                 [],\r\n    };\r\n\r\n    const initSeries = () => {\r\n        sampler.fields          = getFields(options, sampler.expressions);\r\n        sampler.createSample    = createSampleFactory(sampler.fields);\r\n        sampler.cumulatives     = sampler.fields.keys.filter(k => sampler.fields.cumulative[k]);\r\n        sampler.blank           = deleteKeys(sampler.createSample(), sampler.cumulatives);\r\n    }\r\n\r\n    function getSampleTime(time: number) {\r\n        if (sampler.interval) return time - (time % sampler.interval); \r\n        return time;\r\n    }\r\n\r\n    function calculateExpressions(currSlot: any, track: ClosedCircuitBuffer) {\r\n        sampler.expressions.forEach(expr => {\r\n            const result = expr.expression(track.series);\r\n            if (typeof result !== 'undefined') {\r\n                currSlot[expr.name] = result;\r\n            }\r\n        })\r\n    }\r\n\r\n    function aggregateSample(currSlot: any, data: any, time: number) {\r\n        currSlot.__count++;\r\n        sampler.fields.hiddenKeys.forEach(key => {\r\n            sampler.fields.fn[key](data, currSlot[key], currSlot);\r\n        });\r\n        sampler.fields.publicKeys.forEach(key => {\r\n            if (key === sampler.timeKey) {\r\n                const origTime = time || data[key];\r\n                const sampleTime = getSampleTime(origTime);\r\n                data[key] = sampleTime\r\n            }\r\n            const result = sampler.fields.fn[key](data, currSlot[key], currSlot);\r\n            if (typeof result !== 'undefined') {\r\n                currSlot[key] = result;\r\n            }\r\n        });\r\n    }\r\n\r\n    function ffill(currSlot: any, prevSlot: any) {\r\n        sampler.fields.publicKeys\r\n            .filter(key => !!sampler.fields.fill[key])\r\n            .forEach(key => {\r\n                currSlot[sampler.timeKey] = prevSlot[sampler.timeKey] + sampler.interval;\r\n                currSlot[key] = sampler.fields.fill[key](prevSlot);\r\n            });\r\n        currSlot.__count = 1;\r\n    };\r\n\r\n    function collect(track: ClosedCircuitBuffer, currSlot: any, data: any, time: number) {     \r\n        aggregateSample(currSlot, data, time);\r\n        calculateExpressions(currSlot, track);\r\n    };\r\n    \r\n    function newSamplePredicate(currSlot: any, data: any, time: number, lastPeriodTime: number) {\r\n        const sampleTime = getSampleTime(time);\r\n        // compare elapsed time since last period time\r\n        if (typeof lastPeriodTime === 'undefined') return true;\r\n        if (sampler.interval === 0) return true;\r\n        if (sampleTime - lastPeriodTime >= sampler.interval) return true; \r\n        return false;\r\n    };\r\n    \r\n    function addExpression(name: string, expression: Expression) {\r\n        if (sampler.expressionDict[name]) throw new Error(`A field with the name '${name}' already exists.`)\r\n        sampler.expressionDict[name] = expression;\r\n        sampler.expressions.push({ name, expression });\r\n        initSeries();\r\n        sampler.tracks.forEach(t => t.createSeries());\r\n    }\r\n\r\n    return sampler;\r\n}\r\n\r\n\r\n    \r\n","\r\nimport { value, when } from '.';\r\nimport { SampleFields } from './types';\r\n\r\nconst { min, max, abs } = Math;\r\n\r\nconst time = {\r\n    dataFields: [ 'time' ],\r\n    fields: {\r\n        time:           (d, curr) => value(curr, d.time), \r\n    } as SampleFields,\r\n};\r\n\r\nconst ohlc = {\r\n    dataFields: [ 'price'],\r\n    fields: {\r\n        open:           { fn: (d, curr) => value(curr, d.price), fill: p => p.close }, \r\n        high:           { fn: (d, curr) => max(d.price, value(curr, d.price)), fill: p => p.close }, \r\n        low:            { fn: (d, curr) => min(d.price, value(curr, d.price)), fill: p => p.close },\r\n        close:          { fn: (d) => d.price, fill: p => p.close },\r\n    } as SampleFields,\r\n};\r\n\r\nconst side = {\r\n    dataFields: [ 'buy', 'sell' ],\r\n    fields: {\r\n        // Underscore fields are special:\r\n        // - they are run first\r\n        // - they do not get added to sample (hidden)\r\n        // - they perform some operation \r\n        //   e.g. here they set a value on the data object itself\r\n        _buy:           (d) => when(d.qty > 0, () => d.buy  = 1),\r\n        _sell:          (d) => when(d.qty < 0, () => d.sell = 1),\r\n    } as SampleFields,\r\n};\r\n\r\n\r\nconst volume = {\r\n    dataFields: [ 'qty' ],\r\n    fields: {\r\n        // volume\r\n        buyVol:         { fn: (d, curr) => when(d.buy, value(curr, 0) + d.qty), fill: () => 0 },\r\n        sellVol:        { fn: (d, curr) => when(d.sell, value(curr, 0) + d.qty), fill: () => 0 },\r\n        ttlVol:         { fn: (d, curr) => value(curr, 0) + abs(d.qty), fill: () => 0 },\r\n        netVol:         { fn: (d, curr) => value(curr, 0) + d.qty, fill: () => 0 },\r\n        cumNetVol:      { \r\n                            fn: (d, curr) => value(curr, 0) + d.qty, \r\n                            cumulative: true \r\n                        },\r\n    } as SampleFields,\r\n};\r\n\r\n\r\nconst mv = {\r\n    dataFields: [ 'buy', 'sell', 'price', 'qty', 'ttlMv', 'ttlVol' ],\r\n    fields: {\r\n        // mv\r\n        buyMv:          { fn: (d, curr) => when(d.buy, value(curr, 0) + d.price * d.qty), fill: () => 0 },\r\n        sellMv:         { fn: (d, curr) => when(d.sell, value(curr, 0) + d.price * d.qty), fill: () => 0 },\r\n        ttlMv:          { fn: (d, curr) => value(curr, 0) + d.price * abs(d.qty), fill: () => 0 },\r\n        netMv:          { fn: (d, curr) => value(curr, 0) + d.price * d.qty, fill: () => 0 },\r\n\r\n        // volume weighted\r\n        volWtdPrice:    { fn: (d, curr, acc) => acc.ttlMv / acc.ttlVol, fill: () => 0 },\r\n    } as SampleFields,\r\n};\r\n\r\nconst stats = {\r\n    dataFields: [ 'buy', 'sell' ],\r\n    fields: {\r\n        // counts\r\n        ttlTradeCount:  { fn: (d, curr) => value(curr, 0) + 1, fill: () => 0 },\r\n        buyTradeCount:  { fn: (d, curr) => when(d.buy, value(curr, 0) + 1), fill: () => 0 },\r\n        sellTradeCount: { fn: (d, curr) => when(d.sell, value(curr, 0) + 1), fill: () => 0 },\r\n    } as SampleFields,\r\n};\r\n\r\n\r\nexport default {\r\n    cryptoTrade: {\r\n        time,\r\n        ohlc,    \r\n        side,\r\n        volume,\r\n        mv,\r\n        stats,\r\n    },\r\n};\r\n\r\n    \r\n","import SamplingBuffer from './SamplingBuffer';\r\nimport ClosedCircuitBuffer from './ClosedCircuitBuffer';\r\nimport Serie from './Serie';\r\nimport { ConditionalOp } from \"./types\";\r\n\r\nimport FieldGroups from './FieldGroups';\r\n\r\nexport function value(value: any, defaultValue: any) {\r\n    return typeof value !== 'undefined' ? value : defaultValue;\r\n}\r\n\r\nexport function when(condition: boolean, value: number | undefined | ConditionalOp) {\r\n    if (condition) {\r\n        if (typeof value === 'function') {\r\n            return value();\r\n        }\r\n        return value;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport { SamplingBuffer, ClosedCircuitBuffer, Serie, FieldGroups };","import ClosedCircuitBuffer from \"./ClosedCircuitBuffer\";\r\nimport { BufferFilter, Expression, Sampler, SamplerOptions, TrackDictionary } from './types';\r\n\r\nimport { createSampler } from './createSampler';\r\n\r\nimport { value as valueOrDefault } from '.';\r\nimport Serie from \"./Serie\";\r\n\r\nconst noFilter = () => true;\r\n\r\nclass MultiTrackBuffer {  \r\n\r\n  timer:          any;\r\n  sampler:        Sampler;\r\n  tracks:         TrackDictionary = {};\r\n  sampling:       boolean         = false;\r\n  \r\n  // -- EVENTS \r\n  onTrackStart?:  (track: ClosedCircuitBuffer) => void;\r\n  onInterval?:    () => void;\r\n  \r\n  constructor(options: SamplerOptions) {\r\n    this.sampler = createSampler(options);\r\n  }\r\n\r\n  addExpression(name: string, expression: Expression) {\r\n    this.sampler.addExpression(name, expression);\r\n  }\r\n\r\n  getTracks(filter?: BufferFilter) {\r\n    return Object.entries(this.tracks)\r\n      .filter(kv => (filter || (() => true))(kv[0], kv[1]))\r\n      .map(kv => kv[1]);\r\n  }\r\n  \r\n  startSampling() {\r\n    if (this.sampler.suppressAutoSampling) return;\r\n    if (this.sampling) return;\r\n    \r\n    const _instance = this;\r\n\r\n    // timer for buffer group\r\n    this.timer = setInterval(\r\n      () => {\r\n        _instance.sampler.tracks.forEach((_track) => {\r\n          _track.nextSample('timer')\r\n        })\r\n        if (_instance.onInterval) {\r\n          _instance.onInterval();\r\n        }\r\n      }, this.sampler.interval\r\n    );\r\n\r\n    this.sampling = true;\r\n  }\r\n\r\n  stopSampling() {\r\n    clearInterval(this.timer);\r\n    this.sampling = false;\r\n  }\r\n\r\n  preload(data: any, filter?: BufferFilter) {\r\n    this.createDataTracks(data);\r\n    Object.entries(this.tracks)\r\n      .filter(kv => (filter || noFilter)(kv[0], kv[1]))\r\n      .forEach(kv => kv[1].preload(data));\r\n  }\r\n\r\n  capture(data: any, filter?: BufferFilter) {\r\n    this.createDataTracks(data);\r\n    Object.entries(this.tracks)\r\n      .filter(kv => (filter || noFilter)(kv[0], kv[1]))\r\n      .forEach(kv => kv[1].capture(data));\r\n  }\r\n\r\n  createDataTracks(data: any) {\r\n    const _instance = this;\r\n    const sampler = this.sampler;\r\n    const trackKey: string = sampler.trackKeys.map(\r\n      pk => valueOrDefault(data[pk], '')\r\n    ).join('.');\r\n    if (!_instance.tracks[trackKey]) {\r\n        const track = new ClosedCircuitBuffer(sampler.bufferLength, sampler);\r\n        sampler.trackKeys.forEach(pk => {\r\n          track.tags[pk] = data[pk];\r\n        })\r\n        track.key = trackKey;\r\n        _instance.tracks[trackKey] = track;\r\n        sampler.tracks.push(track);\r\n        if (_instance.onTrackStart) {\r\n          _instance.onTrackStart(track);\r\n        }\r\n        \r\n    }\r\n  }\r\n}\r\n\r\nexport default MultiTrackBuffer;\r\n","import React, { useCallback, useEffect, useState } from \"react\";\r\nimport DataTable from './DataTable';\r\nimport { SamplingBuffer, ClosedCircuitBuffer, FieldGroups } from \"@reactiff/sampling-buffer\";\r\nimport RandomWalk from '@reactiff/random-walk';\r\n\r\nconst rndWalk = new RandomWalk(1, 1000, 500, 10, 10);\r\n\r\nconst buffer = new SamplingBuffer({\r\n  interval:       1000,               // in milliseconds\r\n  bufferLength:   30,                 // total samples in closed circuit buffer\r\n  trackKeys:      ['exch'],           // create track for each unique combination of these data fields\r\n  fields:         {\r\n    ...FieldGroups.cryptoTrade.time.fields,\r\n    ...FieldGroups.cryptoTrade.ohlc.fields,\r\n    ...FieldGroups.cryptoTrade.side.fields,\r\n    ...FieldGroups.cryptoTrade.stats.fields,\r\n    ...FieldGroups.cryptoTrade.volume.fields,\r\n    ...FieldGroups.cryptoTrade.mv.fields,\r\n  },\r\n});\r\n\r\nbuffer.addExpression('sma10', (series: any) => {\r\n  return series.close.mean(10)\r\n})\r\n\r\nbuffer.addExpression('ema10', (series: any) => {\r\n  \r\n  const n = 10;\r\n  const key = `ema${n}`;\r\n  \r\n  const price = series.close;\r\n  const calcSerie = series[key];\r\n  \r\n  if (calcSerie.availableLength < n + 1) {\r\n    return undefined;\r\n  }\r\n\r\n  let prev = calcSerie.value(-1);\r\n  if (!prev) {\r\n    prev = price.mean(n, -1);\r\n  }\r\n\r\n  const k = 2 / (n + 1);\r\n  const ema = price.value() * k + prev * (1 - k);\r\n\r\n  return ema;\r\n})\r\n\r\nbuffer.addExpression('cross', (_: any) => {\r\n\r\n  // check cross to the up side\r\n  if (_.ema10.value( 0) > _.sma10.value( 0) &&\r\n      _.ema10.value(-1) < _.sma10.value(-1)) {\r\n        return 1;\r\n  }\r\n\r\n  // check cross to the down side\r\n  if (_.ema10.value( 0) < _.sma10.value( 0) &&\r\n      _.ema10.value(-1) > _.sma10.value(-1)) {\r\n        return -1;\r\n  }\r\n  \r\n  return undefined;\r\n});\r\n\r\nfunction simulateTradeEvent(time: number) {\r\n  const trade = {\r\n    time,\r\n    exch:   'RNDWALK',\r\n    price:  Math.round(rndWalk.next()),\r\n    qty:    Math.round(Math.random() * 100 - 50),\r\n  };\r\n  buffer.capture( trade , \r\n    (name, track) => track.tags.exch === trade.exch\r\n  );\r\n}\r\n\r\nexport default () => {\r\n\r\n  const m = React.useRef({ index: 0, time: 0, clickIndex: 0, periods: 5, tickCount: 0, initialized: false, stopped: false }).current;\r\n  const [columns, setColumns] = useState<string[]>([]);\r\n  const [fifoData, setFifoData] = useState<any[]>([]);\r\n\r\n  const readTrackData = React.useCallback((track: ClosedCircuitBuffer) => {\r\n    let cols: string[] = [];\r\n    const fifos = new Array(track.length);\r\n    track.fifo((pos, buffer) => {\r\n      fifos[pos.ordinal] = buffer[pos.index];\r\n      cols = Object.keys(fifos[pos.ordinal]);\r\n    });\r\n    setColumns(cols);\r\n    setFifoData(fifos);\r\n  }, []);\r\n\r\n\r\n  useEffect(() => {\r\n    \r\n    buffer.onTrackStart = (track) => {\r\n      track.onUpdate = () => {\r\n        readTrackData(track);\r\n      }\r\n    };\r\n\r\n    buffer.onInterval = () => {\r\n      const track = Object.values(buffer.tracks)[0];\r\n      readTrackData(track);\r\n    }\r\n\r\n    \r\n\r\n    buffer.startSampling();\r\n\r\n  }, [readTrackData]);\r\n\r\n\r\n  // simulate trade events\r\n  useEffect(() => {\r\n    const delayCapture = () => {\r\n      simulateTradeEvent(new Date().getTime());\r\n      if (!m.stopped) {\r\n        setTimeout(delayCapture, 0);\r\n      }\r\n    };\r\n    delayCapture();\r\n  }, [m.stopped]);\r\n\r\n  // read data\r\n  // useEffect(() => {\r\n  //   for (let i = 0; i < data.items.length; i++) {\r\n  //     const trade = {\r\n  //       time:   data.items[i][0],\r\n  //       price:  data.items[i][2],\r\n  //       vema10: data.items[i][4],\r\n  //     };\r\n  //     buffer.capture(trade);\r\n  //   }\r\n  // }, []);\r\n\r\n  const handleClick = useCallback(() => {\r\n    \r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      <div className=\"flex row justify-center align-center fill\" onClick={handleClick}>\r\n        <div className=\"flex column\"> \r\n          <div style={{marginBottom: 15}}>\r\n            {\r\n              <DataTable cols={columns} items={fifoData} />\r\n            }\r\n          </div>\r\n        </div>\r\n      </div>\r\n  </>\r\n  )\r\n};\r\n","import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\n\r\nimport './css/index.css'\r\nimport './css/orthogonal.css'\r\nimport './css/flex.css'\r\n\r\nimport App from './App'\r\n\r\nReactDOM.render(<App />, document.getElementById('root'))\r\n"],"sourceRoot":""}