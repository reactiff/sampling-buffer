{"version":3,"sources":["DataTable/Header.tsx","DataTable/TableRow.tsx","DataTable/index.tsx","../../src/Serie/index.ts","../../src/ClosedCircuitBuffer.ts","../../src/createSampler.ts","../../src/SamplingBuffer.ts","../../src/index.ts","tradeSampleFields.ts","App.tsx","RandomWalk.ts","index.tsx"],"names":["Header","props","cols","map","c","index","key","TableRow","item","isArray","Array","className","value","toFixed","Table","items","cellPadding","cellSpacing","length","itemIndex","fnMin","serie","availLength","options","elements","pos","buffer","Math","fnMax","fnMean","sum","cnt","fnCustom","callback","fnStDev","mean","sumOfSq","val","attachAggregateFn","offset","Error","fn","n","Serie","Object","this","attachCustomAggregateFn","createSerie","field","track","getOffsetAdjAvailableLength","ClosedCircuitBuffer","tags","array","cursor","counter","serieInstances","series","arrayLike","sampler","get","getIndex","createSeries","keys","fields","_instance","Proxy","target","nextSample","currentTime","current","__count","prevSlot","fillMissingSamples","normallySkippedMax","interval","missingSamples","time","elapsed","i","insertedTime","lastPeriodTime","preload","sampleTime","getSampleTime","data","shouldAdvance","capture","captureTime","lifo","limit","absOffset","requestedLmt","offsetAdjLmt","relative","ordinal","j","fifo","arrlen","lmt","parseField","fieldDict","getFields","publicKeys","hiddenKeys","expressionKeys","hidden","cumulative","fill","d","parseFieldsAsArray","parseFieldsAsDictionary","expressions","expr","createSampleFactory","sample","fnOrValue","params","createSampler","addExpression","name","expression","k","object","obj","keysToDelete","deleteKeys","t","blank","bufferLength","collect","currSlot","result","aggregateSample","calculateExpressions","createSample","cumulatives","expressionDict","ffill","newSamplePredicate","suppressAutoSampling","timeKey","trackKeys","tracks","noFilter","MultiTrackBuffer","sampling","getTracks","kv","filter","startSampling","setInterval","_track","stopSampling","clearInterval","createDataTracks","trackKey","pk","defaultValue","min","max","abs","curr","_buy","when","qty","buy","_sell","sell","ttlTradeCount","buyTradeCount","sellTradeCount","buyVol","sellVol","ttlVol","netVol","cumNetVol","buyMv","price","sellMv","ttlMv","netMv","volWtdPrice","acc","open","p","close","high","low","rndWalk","start","maxTrend","maxStep","trendRem","trendDir","random","round","createTrend","step","SamplingBuffer","tradeSampleFields","calcSerie","availableLength","prev","_","ema10","sma10","m","React","useRef","clickIndex","periods","tickCount","initialized","stopped","useState","columns","setColumns","fifoData","setFifoData","readTrackData","useCallback","fifos","useEffect","onTrackStart","onUpdate","onInterval","values","delayCapture","trade","exch","next","simulateTradeEvent","Date","getTime","setTimeout","handleClick","onClick","style","marginBottom","DataTable","ReactDOM","render","App","document","getElementById"],"mappings":"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","file":"static/js/main.8fcb87d7.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nconst Header = (props: any) => {\r\n    \r\n    const cols = props.cols || [];\r\n\r\n    return <thead>\r\n        <tr>\r\n            {\r\n                cols.map((c: any, index: number) => {\r\n                    return <th key={index}>{c}</th>\r\n                })\r\n            }\r\n        </tr>\r\n    </thead>\r\n}\r\n\r\nexport default Header;","import React from 'react';\r\n\r\nconst TableRow = (props: any) => {\r\n    \r\n    const item = props.item;\r\n    const cols = props.cols;\r\n\r\n    const isArray = Array.isArray(item);\r\n\r\n    return (\r\n        <tr className=\"no-text-overflow\">\r\n\r\n            {\r\n                isArray &&\r\n                item.map((value: any, index: number) => {\r\n                    return <td key={cols[index]}>\r\n                        {\r\n                            typeof value === 'number' &&\r\n                            value.toFixed(0)\r\n                        }\r\n                    </td>\r\n                })   \r\n            }\r\n\r\n            {\r\n                !isArray &&\r\n                cols.map((c: any, index: number) => {\r\n                    return <td key={cols[index]}>\r\n                        {\r\n                            typeof item[c] === 'number' &&\r\n                            item[c].toFixed(0)\r\n                        }\r\n                    </td>\r\n                })\r\n            }\r\n        </tr>\r\n    )\r\n}\r\n\r\nexport default TableRow;","import React from 'react'\r\nimport Header from './Header';\r\nimport TableRow from './TableRow';\r\nimport './style.css';\r\n\r\ntype Props = {\r\n    cols: string[],\r\n    items: any[],\r\n};\r\n\r\nconst Table = (props: Props) => {\r\n\r\n    const cols: string[] = props.cols;\r\n    const items = props.items;\r\n\r\n    if (!items) return null;\r\n\r\n    \r\n\r\n    return <table cellPadding={0} cellSpacing={0} className=\"data-table\" >\r\n        \r\n        {\r\n            cols && \r\n            cols.length > 0 &&\r\n            <Header cols={cols} />\r\n        }\r\n\r\n        <tbody>\r\n            {\r\n                items.map((item: any, itemIndex: number ) => (\r\n                    <TableRow key={itemIndex} item={item} cols={cols} />\r\n                ))\r\n            }\r\n        </tbody>\r\n    </table>\r\n    \r\n};\r\n\r\nexport default Table;\r\n","import ClosedCircuitBuffer from \"../ClosedCircuitBuffer\";\r\nimport { SerieOptions, AggregateFn1Def, AggregateFn1, CustomAggregateFnDef, CustomAggregateFn, CustomAggregateVoidCallback } from '../types';\r\n\r\n\r\nconst fnMin: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset: number) => {\r\n    const availLength = options.track.getOffsetAdjAvailableLength(offset);\r\n    if (availLength < n) return undefined;\r\n\r\n    const elements  = new Array(availLength);\r\n    options.track.lifo((pos, buffer) => {\r\n        elements[pos.ordinal] = buffer[pos.index][options.field];\r\n    }, offset, availLength)\r\n    \r\n    return Math.min(...elements);\r\n}\r\n\r\nconst fnMax: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset: number) => {\r\n    const availLength = options.track.getOffsetAdjAvailableLength(offset);\r\n    if (availLength < n) return undefined;\r\n\r\n    const elements  = new Array(availLength);\r\n    options.track.lifo((pos, buffer) => {\r\n        elements[pos.ordinal] = buffer[pos.index][options.field];\r\n    }, offset, availLength)\r\n    \r\n    return Math.max(...elements);\r\n}\r\n\r\n\r\nconst fnSum: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset: number) => {\r\n    const availLength = options.track.getOffsetAdjAvailableLength(offset);\r\n    if (availLength < n) return undefined;\r\n    \r\n    let sum = 0;\r\n    options.track.lifo((pos, buffer) => {\r\n        sum += buffer[pos.index][options.field];\r\n    }, offset, availLength)\r\n    \r\n    return sum;\r\n}\r\n\r\nconst fnMean: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset: number) => {\r\n    const availLength = options.track.getOffsetAdjAvailableLength(offset);\r\n    if (availLength < n) return undefined;\r\n    \r\n    let sum = 0;\r\n    let cnt = 0;\r\n\r\n    options.track.lifo((pos, buffer) => {\r\n        sum += buffer[pos.index][options.field];\r\n        cnt++;\r\n    }, offset, availLength)\r\n    \r\n    return sum / cnt;\r\n}\r\n\r\nconst fnCustom = (serie: Serie, options: SerieOptions, n: number, offset: number, callback: CustomAggregateVoidCallback) => {\r\n    const availLength = options.track.getOffsetAdjAvailableLength(offset);\r\n    if (availLength < n) return undefined;\r\n    options.track.lifo((pos, buffer) => {\r\n        callback(pos, buffer[pos.index][options.field])\r\n    }, offset, availLength);\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Uses Bessel's correction of bias.\r\n * @param {array} array \r\n */\r\n \r\nconst fnStDev: AggregateFn1Def = (serie: Serie, options: SerieOptions, n: number, offset: number) => {\r\n    const availLength = options.track.getOffsetAdjAvailableLength(offset);\r\n    if (availLength === 0) return undefined;\r\n\r\n    const mean = serie.mean(n, offset)!;\r\n\r\n    let sumOfSq = 0;\r\n    let cnt = 0;\r\n    serie.fn(n, offset, (pos, val) => {\r\n        sumOfSq += (val - mean) ** 2;\r\n        cnt++;\r\n    });\r\n\r\n    return Math.sqrt(sumOfSq / cnt);\r\n}\r\n\r\nfunction attachAggregateFn(serie: Serie, options: SerieOptions, fn: AggregateFn1Def) {\r\n    return (n: number, offset = 0) => {\r\n        if (offset > 0) throw new Error('offset must be negative');\r\n        return fn(serie, options, n, offset);\r\n    };\r\n}\r\nfunction attachCustomAggregateFn(serie: Serie, options: SerieOptions, fn: CustomAggregateFnDef) {\r\n    return (n: number, offset = 0, callback: CustomAggregateVoidCallback) => {\r\n        if (offset > 0) throw new Error('offset must be negative');\r\n        return fn(serie, options, n, offset, callback);\r\n    };\r\n}\r\n\r\nexport default class Serie {\r\n    \r\n    fn:  CustomAggregateFn;\r\n    min: AggregateFn1;\r\n    max: AggregateFn1;\r\n\r\n    mean: AggregateFn1;\r\n    \r\n    stDev: AggregateFn1;\r\n\r\n    value: (offset?: number) => number | undefined;\r\n\r\n    track: ClosedCircuitBuffer;\r\n    field: string;\r\n\r\n    constructor(options: SerieOptions) {\r\n        Object.assign(this, options);\r\n\r\n        this.min = attachAggregateFn(this, options, fnMin);\r\n        this.max = attachAggregateFn(this, options, fnMax);\r\n        this.mean = attachAggregateFn(this, options, fnMean);\r\n        \r\n        this.fn  = attachCustomAggregateFn(this, options, fnCustom);\r\n\r\n        this.stDev = attachAggregateFn(this, options, fnStDev);\r\n\r\n        this.value = (offset = 0) => {\r\n            const availLength = this.track.getOffsetAdjAvailableLength(offset);\r\n            if (availLength === 0) return undefined;\r\n            return this.track.get(offset)[this.field];\r\n        }\r\n    }\r\n\r\n    get availableLength() {\r\n        const availLength = this.track.getOffsetAdjAvailableLength(0);\r\n        return availLength;\r\n    }\r\n\r\n    \r\n\r\n    static createSerie(field: string, track: ClosedCircuitBuffer) {\r\n        return new Serie({\r\n            field,\r\n            track,\r\n        });\r\n    }\r\n}","import Serie from './Serie';\r\nimport {\r\n    IteratorCallback,\r\n    IteratorPosition,\r\n    NewSamplePredicate,\r\n    Sampler,\r\n    SerieFactory,\r\n} from './types';\r\n\r\nclass ClosedCircuitBuffer {\r\n    \r\n    key: string;\r\n    tags: any = {};\r\n\r\n    array: any[] = [];\r\n    cursor: number = 0;\r\n    counter = 0;\r\n\r\n    shouldAdvance: NewSamplePredicate;\r\n\r\n    // prevSample: any;\r\n    lastPeriodTime: number;\r\n    sampler: Sampler;\r\n\r\n    onUpdate?: () => void;\r\n    lastAdvanceTime?: number;\r\n\r\n    serieInstances: any = {};\r\n    series: { [index: string]: SerieFactory } = {};\r\n\r\n    constructor(length: number, sampler: Sampler) {\r\n        const arrayLike = { length }; \r\n        this.sampler = sampler!;\r\n        this.array = Array.from(arrayLike).map(this.sampler.createSample);\r\n        this.cursor = length ? 0 : -1;\r\n        this.shouldAdvance = this.sampler.newSamplePredicate;\r\n        this.createSeries();\r\n    }\r\n    \r\n    getOffsetAdjAvailableLength(offset: number) {\r\n        return Math.max(\r\n            0,\r\n            Math.min(this.array.length, this.counter + 1) - Math.abs(offset)\r\n        );\r\n    }\r\n\r\n    get length() {\r\n        return this.array.length;\r\n    }\r\n\r\n    get current() {\r\n        return this.array[this.cursor];\r\n    }\r\n\r\n    get(offset = 0) {\r\n        return this.array[this.getIndex(offset)];\r\n    }\r\n\r\n    getIndex(offset = 0) {\r\n        let index = this.cursor + offset\r\n        if (offset > 0) {\r\n            return index  % this.array.length;\r\n        }\r\n        while (index < 0) {\r\n            index = this.array.length + index;\r\n        }\r\n        return index;\r\n    }\r\n\r\n    createSeries() {\r\n        const keys = [\r\n            ...this.sampler.fields.publicKeys,\r\n            ...this.sampler.fields.expressionKeys,\r\n        ];\r\n\r\n        this.serieInstances = {};\r\n        const series = {};\r\n\r\n        const _instance = this;\r\n        keys.forEach(key => {\r\n            series[key] = () => {\r\n                if (!_instance.serieInstances[key]) {\r\n                    _instance.serieInstances[key] = Serie.createSerie(key, _instance);\r\n                }\r\n                return _instance.serieInstances[key];\r\n            }\r\n        })\r\n\r\n        const seriesHandler = {\r\n            get: (target, prop, receiver) => {\r\n                return target[prop]();\r\n            }\r\n        };\r\n        \r\n        this.series = new Proxy(series, seriesHandler);\r\n    }\r\n    \r\n    nextSample(caller: string) {\r\n        \r\n        const currentTime = this.current[this.sampler.timeKey];\r\n        this.lastAdvanceTime = currentTime;\r\n\r\n        // see if the current slot hasn't received any data and fill forward from last slot\r\n        if (this.current.__count === 0) {    \r\n            const prevSlot = this.get(-1);\r\n            if (prevSlot.__count) {\r\n                this.sampler.ffill(this.current, prevSlot);                          \r\n            }\r\n        }  \r\n\r\n        this.counter++;\r\n        this.cursor++;\r\n        if (this.cursor === this.array.length) {\r\n            this.cursor = 0;\r\n        }\r\n        \r\n        Object.assign(this.array[this.cursor], this.sampler.blank);\r\n\r\n        this.array[this.cursor][this.sampler.timeKey] = currentTime + this.sampler.interval;\r\n    };\r\n\r\n    fillMissingSamples(time: number) {\r\n        // when loading from history, we need to account for missing data\r\n        // and insert missing samples, something that would normally\r\n        // be taken care of by the timer\r\n\r\n        let normallySkippedMax = 1;\r\n        if (this.sampler.suppressAutoSampling) {\r\n            normallySkippedMax = 0;\r\n        }\r\n\r\n        if (this.sampler.interval > 0 && this.lastPeriodTime) {\r\n            const elapsed = time - this.lastPeriodTime;\r\n            const missingSamples = elapsed / this.sampler.interval - normallySkippedMax;\r\n            if (missingSamples > 0) {\r\n                for (let i = 0; i<missingSamples; i++) {\r\n                    const offset = this.sampler.interval;\r\n                    const insertedTime = this.lastPeriodTime + offset;\r\n                    this.nextSample('fillMissingSamples');\r\n                    this.lastPeriodTime = insertedTime;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Preload buffer with history data\r\n     * @param data \r\n     */\r\n    preload(data: any) {\r\n\r\n        const sampleTime = this.sampler.getSampleTime(data.time);\r\n        \r\n        this.fillMissingSamples(sampleTime)\r\n\r\n        this.sampler.collect(this, this.current, data, sampleTime);\r\n        \r\n        if (this.shouldAdvance(this.current, data, sampleTime, this.lastPeriodTime)) {\r\n            this.nextSample('preload'); \r\n            this.lastPeriodTime = sampleTime;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Record real-time data from a stream\r\n     * @param data \r\n     * @returns \r\n     */\r\n    capture(data: any, time?: number) {\r\n        const captureTime = time || data[this.sampler.timeKey];\r\n        const sampleTime = this.sampler.getSampleTime(captureTime);\r\n\r\n        if (!this.lastPeriodTime) {\r\n            this.lastPeriodTime = sampleTime;\r\n        }\r\n        // if any samples were skipped, fill them before capturing\r\n        if (this.sampler.interval > 0 && this.sampler.suppressAutoSampling) {\r\n            this.fillMissingSamples(sampleTime);\r\n        }\r\n\r\n        this.sampler.collect(this, this.current, data, sampleTime);\r\n\r\n        if (this.sampler.interval === 0) {\r\n            this.nextSample('capture'); \r\n            this.lastPeriodTime = sampleTime;\r\n        }\r\n        \r\n        this.onUpdate && this.onUpdate();\r\n    }\r\n    \r\n    lifo(callback: IteratorCallback, offset: number, limit = -1) {\r\n        const absOffset     = Math.abs(offset || 0);\r\n        const requestedLmt  = limit >= 0 ? Math.abs(limit) : 0;\r\n        const offsetAdjLmt  = this.array.length - absOffset;\r\n        \r\n        const pos: IteratorPosition = {\r\n            index: this.cursor - absOffset, // starting position (adjusted for offset)\r\n            relative: 0,                    \r\n            ordinal: 0,                     // zero based iteration number\r\n        };\r\n\r\n        let j   = this.array.length;\r\n        while (j--) {\r\n\r\n            if (absOffset  && pos.ordinal >= offsetAdjLmt) {\r\n                break;\r\n            }\r\n            if (limit >= 0 && pos.ordinal >= requestedLmt) {\r\n                break;\r\n            }\r\n\r\n            // loop around\r\n            if (pos.index < 0) {\r\n                pos.index = this.array.length - 1; \r\n            }\r\n\r\n            callback(\r\n                pos,\r\n                this.array\r\n            );\r\n\r\n            pos.ordinal++;\r\n            pos.index--;\r\n            pos.relative--;\r\n        }\r\n    }\r\n\r\n    fifo(callback: IteratorCallback, limit = -1) {\r\n        const arrlen = this.array.length;\r\n        let lmt = limit >= 0 ? limit : arrlen;\r\n\r\n        const pos: IteratorPosition = {\r\n            index: 0,                   \r\n            relative: -(arrlen - 1),                    \r\n            ordinal: 0,                 \r\n        };\r\n\r\n        let j = arrlen;\r\n        let i = 0;\r\n        while (j-- && lmt--) {\r\n            pos.index = (arrlen + this.cursor - j) % arrlen;\r\n\r\n            callback(\r\n                pos,\r\n                this.array\r\n            );\r\n\r\n            pos.ordinal++;\r\n            pos.relative++;\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n}\r\n\r\nexport default ClosedCircuitBuffer;","import ClosedCircuitBuffer from \"./ClosedCircuitBuffer\";\r\n\r\nimport Serie from \"./Serie\";\r\nimport { Sampler, SamplerOptions, FieldDict, Expression, SampleFieldDictEntry, SampleFieldArrayItem } from \"./types\";\r\n\r\nfunction deleteKeys(object: any, keysToDelete: string[]) {\r\n    const obj: any = {...object};\r\n    keysToDelete.forEach(key => delete obj[key]);\r\n    return obj;\r\n}\r\n\r\nfunction parseField(fieldDict: FieldDict, key: string, value: any) {\r\n\r\n    fieldDict.keys.push(key);\r\n    \r\n    // hidden\r\n    if (key[0] === '_' && key[1] !== '_') {\r\n        fieldDict.hidden[key] = true;\r\n        fieldDict.hiddenKeys.push(key);\r\n    } else {\r\n        fieldDict.publicKeys.push(key);\r\n    }\r\n\r\n    if (typeof value === 'function') {\r\n        fieldDict.fn[key] = value;\r\n    } \r\n    else if (typeof value === 'object') {\r\n        if (!!value.cumulative) {\r\n            fieldDict.cumulative[key] = true;\r\n        }\r\n        fieldDict.fn[key] = value.fn;\r\n        fieldDict.fill[key] = value.fill;\r\n    } \r\n    else { // number\r\n        fieldDict.fn[key] = () => value;\r\n    }\r\n}\r\n\r\nfunction parseFieldsAsArray(fieldDict: FieldDict, options: SamplerOptions) {\r\n    const fields = options.fields as SampleFieldArrayItem[];\r\n    fields.forEach(field => {\r\n        switch (typeof field) {\r\n            case 'string':\r\n                parseField(fieldDict, field, d => d[field] )\r\n                break;\r\n            default: // must be of type SampleFieldNamed\r\n                parseField(fieldDict, field.name, field)\r\n                break;\r\n        }\r\n    });\r\n}\r\n\r\nfunction parseFieldsAsDictionary(fieldDict: FieldDict, options: SamplerOptions) {\r\n    Object.entries(options.fields).forEach(([key, value]) => {\r\n        parseField(fieldDict, key, value);\r\n    });\r\n}\r\n\r\nfunction getFields(options: SamplerOptions, expressions: any[]) {\r\n    const fieldDict: FieldDict = {\r\n        keys: [],\r\n        publicKeys: [],\r\n        hiddenKeys: [],\r\n        expressionKeys: [],\r\n        hidden: {},\r\n        cumulative: {},\r\n        fn: {},\r\n        fill: {},\r\n    };\r\n\r\n    if (Array.isArray(options.fields)) {\r\n        parseFieldsAsArray(fieldDict, options);\r\n    } else {\r\n        parseFieldsAsDictionary(fieldDict, options);\r\n    }\r\n\r\n    expressions.forEach((expr: any) => {\r\n        fieldDict.expressionKeys.push(expr.name);\r\n    });\r\n\r\n    return fieldDict;\r\n}\r\n\r\nfunction createSampleFactory(fields: FieldDict) {\r\n    const sample = { __count: 0 };\r\n    fields.publicKeys.forEach(key => {\r\n        sample[key] = undefined;\r\n    });\r\n    fields.expressionKeys.forEach(key => {\r\n        sample[key] = undefined;\r\n    });\r\n    return () => ({ ...sample });\r\n}\r\n\r\nconst fnOrValue = (value: any, ...params: any[]) => {\r\n    if (typeof value === 'function') return value(...params);\r\n    return value;\r\n}\r\n\r\nexport function createSampler(options: SamplerOptions) {\r\n\r\n    const fields = getFields(options, []);\r\n\r\n    const sampler: Sampler = {\r\n        addExpression,          // hoisted funciton\r\n        blank:                  {},\r\n        bufferLength:           options.bufferLength,\r\n        collect,                // hoisted funciton\r\n        createSample:           createSampleFactory(fields),\r\n        cumulatives:            [],\r\n        expressionDict:         {},\r\n        expressions:            [],\r\n        ffill,                  // hoisted funciton\r\n        fields,\r\n        getSampleTime,          // hoisted funciton\r\n        interval:               options.interval || 0,\r\n        newSamplePredicate,     // hoisted funciton\r\n        series:                 {},\r\n        suppressAutoSampling:   options.suppressAutoSampling,\r\n        timeKey:                fnOrValue(options.timeKey)  || 'time',\r\n        trackKeys:              options.trackKeys || [],\r\n        tracks:                 [],\r\n    };\r\n\r\n    const initSeries = () => {\r\n        sampler.fields          = getFields(options, sampler.expressions);\r\n        sampler.createSample    = createSampleFactory(sampler.fields);\r\n        sampler.cumulatives     = sampler.fields.keys.filter(k => sampler.fields.cumulative[k]);\r\n        sampler.blank           = deleteKeys(sampler.createSample(), sampler.cumulatives);\r\n    }\r\n\r\n    function getSampleTime(time: number) {\r\n        if (sampler.interval) return time - (time % sampler.interval); \r\n        return time;\r\n    }\r\n\r\n    function calculateExpressions(currSlot: any, track: ClosedCircuitBuffer) {\r\n        sampler.expressions.forEach(expr => {\r\n            const result = expr.expression(track.series);\r\n            if (typeof result !== 'undefined') {\r\n                currSlot[expr.name] = result;\r\n            }\r\n        })\r\n    }\r\n\r\n    function aggregateSample(currSlot: any, data: any, time: number) {\r\n        currSlot.__count++;\r\n        sampler.fields.hiddenKeys.forEach(key => {\r\n            sampler.fields.fn[key](data, currSlot[key], currSlot);\r\n        });\r\n        sampler.fields.publicKeys.forEach(key => {\r\n            if (key === sampler.timeKey) {\r\n                const origTime = time || data[key];\r\n                const sampleTime = getSampleTime(origTime);\r\n                data[key] = sampleTime\r\n            }\r\n            const result = sampler.fields.fn[key](data, currSlot[key], currSlot);\r\n            if (typeof result !== 'undefined') {\r\n                currSlot[key] = result;\r\n            }\r\n        });\r\n    }\r\n\r\n    function ffill(currSlot: any, prevSlot: any) {\r\n        sampler.fields.publicKeys\r\n            .filter(key => !!sampler.fields.fill[key])\r\n            .forEach(key => {\r\n                currSlot[sampler.timeKey] = prevSlot[sampler.timeKey] + sampler.interval;\r\n                currSlot[key] = sampler.fields.fill[key](prevSlot);\r\n            });\r\n        currSlot.__count = 1;\r\n    };\r\n\r\n    function collect(track: ClosedCircuitBuffer, currSlot: any, data: any, time: number) {     \r\n        aggregateSample(currSlot, data, time);\r\n        calculateExpressions(currSlot, track);\r\n    };\r\n    \r\n    function newSamplePredicate(currSlot: any, data: any, time: number, lastPeriodTime: number) {\r\n        const sampleTime = getSampleTime(time);\r\n        // compare elapsed time since last period time\r\n        if (typeof lastPeriodTime === 'undefined') return true;\r\n        if (sampler.interval === 0) return true;\r\n        if (sampleTime - lastPeriodTime >= sampler.interval) return true; \r\n        return false;\r\n    };\r\n    \r\n    function addExpression(name: string, expression: Expression) {\r\n        if (sampler.expressionDict[name]) throw new Error(`A field with the name '${name}' already exists.`)\r\n        sampler.expressionDict[name] = expression;\r\n        sampler.expressions.push({ name, expression });\r\n        initSeries();\r\n        sampler.tracks.forEach(t => t.createSeries());\r\n    }\r\n\r\n    return sampler;\r\n}\r\n\r\n\r\n    \r\n","import ClosedCircuitBuffer from \"./ClosedCircuitBuffer\";\r\nimport { BufferFilter, Expression, Sampler, SamplerOptions, TrackDictionary } from './types';\r\n\r\nimport { createSampler } from './createSampler';\r\n\r\nimport { value as valueOrDefault } from '.';\r\nimport Serie from \"./Serie\";\r\n\r\nconst noFilter = () => true;\r\n\r\nclass MultiTrackBuffer {  \r\n\r\n  timer:          any;\r\n  sampler:        Sampler;\r\n  tracks:         TrackDictionary = {};\r\n  sampling:       boolean         = false;\r\n  \r\n  // -- EVENTS \r\n  onTrackStart?:  (track: ClosedCircuitBuffer) => void;\r\n  onInterval?:    () => void;\r\n  \r\n  constructor(options: SamplerOptions) {\r\n    this.sampler = createSampler(options);\r\n  }\r\n\r\n  addExpression(name: string, expression: Expression) {\r\n    this.sampler.addExpression(name, expression);\r\n  }\r\n\r\n  getTracks(filter?: BufferFilter) {\r\n    return Object.entries(this.tracks)\r\n      .filter(kv => (filter || (() => true))(kv[0], kv[1]))\r\n      .map(kv => kv[1]);\r\n  }\r\n  \r\n  startSampling() {\r\n    if (this.sampler.suppressAutoSampling) return;\r\n    if (this.sampling) return;\r\n    \r\n    const _instance = this;\r\n\r\n    // timer for buffer group\r\n    this.timer = setInterval(\r\n      () => {\r\n        _instance.sampler.tracks.forEach((_track) => {\r\n          _track.nextSample('timer')\r\n        })\r\n        if (_instance.onInterval) {\r\n          _instance.onInterval();\r\n        }\r\n      }, this.sampler.interval\r\n    );\r\n\r\n    this.sampling = true;\r\n  }\r\n\r\n  stopSampling() {\r\n    clearInterval(this.timer);\r\n    this.sampling = false;\r\n  }\r\n\r\n  preload(data: any, filter?: BufferFilter) {\r\n    this.createDataTracks(data);\r\n    Object.entries(this.tracks)\r\n      .filter(kv => (filter || noFilter)(kv[0], kv[1]))\r\n      .forEach(kv => kv[1].preload(data));\r\n  }\r\n\r\n  capture(data: any, filter?: BufferFilter) {\r\n    this.createDataTracks(data);\r\n    Object.entries(this.tracks)\r\n      .filter(kv => (filter || noFilter)(kv[0], kv[1]))\r\n      .forEach(kv => kv[1].capture(data));\r\n  }\r\n\r\n  createDataTracks(data: any) {\r\n    const _instance = this;\r\n    const sampler = this.sampler;\r\n    const trackKey: string = sampler.trackKeys.map(\r\n      pk => valueOrDefault(data[pk], '')\r\n    ).join('.');\r\n    if (!_instance.tracks[trackKey]) {\r\n        const track = new ClosedCircuitBuffer(sampler.bufferLength, sampler);\r\n        sampler.trackKeys.forEach(pk => {\r\n          track.tags[pk] = data[pk];\r\n        })\r\n        track.key = trackKey;\r\n        _instance.tracks[trackKey] = track;\r\n        sampler.tracks.push(track);\r\n        if (_instance.onTrackStart) {\r\n          _instance.onTrackStart(track);\r\n        }\r\n        \r\n    }\r\n  }\r\n}\r\n\r\nexport default MultiTrackBuffer;\r\n","import SamplingBuffer from './SamplingBuffer';\r\nimport ClosedCircuitBuffer from './ClosedCircuitBuffer';\r\nimport Serie from './Serie';\r\n\r\nimport { ConditionalOp } from \"./types\";\r\n\r\nexport function value(value: any, defaultValue: any) {\r\n    return typeof value !== 'undefined' ? value : defaultValue;\r\n}\r\n\r\nexport function when(condition: boolean, value: number | undefined | ConditionalOp) {\r\n    if (condition) {\r\n        if (typeof value === 'function') {\r\n            return value();\r\n        }\r\n        return value;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport { SamplingBuffer, ClosedCircuitBuffer, Serie };","\r\nimport { value, when } from '@reactiff/sampling-buffer';\r\nimport { SampleFields } from '@reactiff/sampling-buffer/dist/types';\r\n\r\nconst { min, max, abs } = Math;\r\n\r\nexport default {            \r\n        \r\n    time:           (d, curr) => value(curr, d.time), \r\n    \r\n    // Underscore fields are special:\r\n    // - they are run first\r\n    // - they do not get added to sample (hidden)\r\n    // - they perform some operation \r\n    //   e.g. here they set a value on the data object itself\r\n    _buy:           (d) => when(d.qty > 0, () => d.buy  = 1),\r\n    _sell:          (d) => when(d.qty < 0, () => d.sell = 1),\r\n\r\n    \r\n    \r\n\r\n    // counts\r\n    ttlTradeCount:  { fn: (d, curr) => value(curr, 0) + 1, fill: () => 0 },\r\n    buyTradeCount:  { fn: (d, curr) => when(d.buy, value(curr, 0) + 1), fill: () => 0 },\r\n    sellTradeCount: { fn: (d, curr) => when(d.sell, value(curr, 0) + 1), fill: () => 0 },\r\n\r\n    // volume\r\n    buyVol:         { fn: (d, curr) => when(d.buy, value(curr, 0) + d.qty), fill: () => 0 },\r\n    sellVol:        { fn: (d, curr) => when(d.sell, value(curr, 0) + d.qty), fill: () => 0 },\r\n    ttlVol:         { fn: (d, curr) => value(curr, 0) + abs(d.qty), fill: () => 0 },\r\n    netVol:         { fn: (d, curr) => value(curr, 0) + d.qty, fill: () => 0 },\r\n    cumNetVol:      { \r\n                        fn: (d, curr) => value(curr, 0) + d.qty, \r\n                        cumulative: true \r\n                    },\r\n\r\n    // mv\r\n    buyMv:          { fn: (d, curr) => when(d.buy, value(curr, 0) + d.price * d.qty), fill: () => 0 },\r\n    sellMv:         { fn: (d, curr) => when(d.sell, value(curr, 0) + d.price * d.qty), fill: () => 0 },\r\n\r\n    ttlMv:          { fn: (d, curr) => value(curr, 0) + d.price * abs(d.qty), fill: () => 0 },\r\n    netMv:          { fn: (d, curr) => value(curr, 0) + d.price * d.qty, fill: () => 0 },\r\n\r\n    // volume weighted\r\n    volWtdPrice:    { fn: (d, curr, acc) => acc.ttlMv / acc.ttlVol, fill: () => 0 },\r\n\r\n    // price\r\n    open:           { fn: (d, curr) => value(curr, d.price), fill: p => p.close }, \r\n    high:           { fn: (d, curr) => max(d.price, value(curr, d.price)), fill: p => p.close }, \r\n    low:            { fn: (d, curr) => min(d.price, value(curr, d.price)), fill: p => p.close },\r\n    close:          { fn: (d) => d.price, fill: p => p.close },\r\n\r\n    \r\n    \r\n} as SampleFields;\r\n\r\n\r\n\r\n    \r\n","import React, { useCallback, useEffect, useState } from \"react\";\r\nimport DataTable from './DataTable';\r\n\r\nimport { SamplingBuffer, ClosedCircuitBuffer } from \"@reactiff/sampling-buffer\";\r\nimport tradeSampleFields from \"./tradeSampleFields\";\r\nimport RandomWalk from './RandomWalk';\r\n\r\nconst rndWalk = new RandomWalk(1, 1000, 500, 10, 10);\r\n\r\nconst buffer = new SamplingBuffer({\r\n  interval:       1000,               // in milliseconds\r\n  bufferLength:   30,                 // total samples in closed circuit buffer\r\n  trackKeys:      ['exch'],           // create track for each unique combination of these data fields\r\n  fields:         tradeSampleFields,\r\n});\r\n\r\nbuffer.addExpression('sma10', (series: any) => {\r\n  return series.close.mean(10)\r\n})\r\n\r\nbuffer.addExpression('ema10', (series: any) => {\r\n  \r\n  const n = 10;\r\n  const key = `ema${n}`;\r\n  \r\n  const price = series.close;\r\n  const calcSerie = series[key];\r\n  \r\n  if (calcSerie.availableLength < n + 1) {\r\n    return undefined;\r\n  }\r\n\r\n  let prev = calcSerie.value(-1);\r\n  if (!prev) {\r\n    prev = price.mean(n, -1);\r\n  }\r\n\r\n  const k = 2 / (n + 1);\r\n  const ema = price.value() * k + prev * (1 - k);\r\n\r\n  return ema;\r\n})\r\n\r\nbuffer.addExpression('cross', (_: any) => {\r\n\r\n  // check cross to the up side\r\n  if (_.ema10.value( 0) > _.sma10.value( 0) &&\r\n      _.ema10.value(-1) < _.sma10.value(-1)) {\r\n        return 1;\r\n  }\r\n\r\n  // check cross to the down side\r\n  if (_.ema10.value( 0) < _.sma10.value( 0) &&\r\n      _.ema10.value(-1) > _.sma10.value(-1)) {\r\n        return -1;\r\n  }\r\n  \r\n  return undefined;\r\n});\r\n\r\nfunction simulateTradeEvent(time: number) {\r\n  const trade = {\r\n    time,\r\n    exch:   'RNDWALK',\r\n    price:  Math.round(rndWalk.next()),\r\n    qty:    Math.round(Math.random() * 100 - 50),\r\n  };\r\n  buffer.capture( trade , \r\n    (name, track) => track.tags.exch === trade.exch\r\n  );\r\n}\r\n\r\nexport default () => {\r\n\r\n  const m = React.useRef({ index: 0, time: 0, clickIndex: 0, periods: 5, tickCount: 0, initialized: false, stopped: false }).current;\r\n  const [columns, setColumns] = useState<string[]>([]);\r\n  const [fifoData, setFifoData] = useState<any[]>([]);\r\n\r\n  const readTrackData = React.useCallback((track: ClosedCircuitBuffer) => {\r\n    let cols: string[] = [];\r\n    const fifos = new Array(track.length);\r\n    track.fifo((pos, buffer) => {\r\n      fifos[pos.ordinal] = buffer[pos.index];\r\n      cols = Object.keys(fifos[pos.ordinal]);\r\n    });\r\n    setColumns(cols);\r\n    setFifoData(fifos);\r\n  }, []);\r\n\r\n\r\n  useEffect(() => {\r\n    \r\n    buffer.onTrackStart = (track) => {\r\n      track.onUpdate = () => {\r\n        readTrackData(track);\r\n      }\r\n    };\r\n\r\n    buffer.onInterval = () => {\r\n      const track = Object.values(buffer.tracks)[0];\r\n      readTrackData(track);\r\n    }\r\n\r\n    \r\n\r\n    buffer.startSampling();\r\n\r\n  }, [readTrackData]);\r\n\r\n\r\n  // simulate trade events\r\n  useEffect(() => {\r\n    const delayCapture = () => {\r\n      simulateTradeEvent(new Date().getTime());\r\n      if (!m.stopped) {\r\n        setTimeout(delayCapture, 0);\r\n      }\r\n    };\r\n    delayCapture();\r\n  }, [m.stopped]);\r\n\r\n  // read data\r\n  // useEffect(() => {\r\n  //   for (let i = 0; i < data.items.length; i++) {\r\n  //     const trade = {\r\n  //       time:   data.items[i][0],\r\n  //       price:  data.items[i][2],\r\n  //       vema10: data.items[i][4],\r\n  //     };\r\n  //     buffer.capture(trade);\r\n  //   }\r\n  // }, []);\r\n\r\n  const handleClick = useCallback(() => {\r\n    \r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      <div className=\"flex row justify-center align-center fill\" onClick={handleClick}>\r\n        <div className=\"flex column\"> \r\n          <div style={{marginBottom: 15}}>\r\n            {\r\n              <DataTable cols={columns} items={fifoData} />\r\n            }\r\n          </div>\r\n        </div>\r\n      </div>\r\n  </>\r\n  )\r\n};\r\n","export default class RandomWalk {\r\n\r\n    min: number;\r\n    max: number;\r\n    maxTrend: number;\r\n    maxStep: number;\r\n    value: number;\r\n    trendRem: number;\r\n    trendDir: number;\r\n\r\n    constructor(min: number, max: number, start: number, maxTrend: number, maxStep: number) {\r\n        this.min = min;\r\n        this.max = max;\r\n        this.maxTrend = maxTrend;\r\n        this.maxStep = maxStep;\r\n        this.value = start || Math.random() * ((max - min)/2) + min;\r\n        this.trendRem = 0;\r\n        this.trendDir = 0;\r\n    }\r\n\r\n    createTrend() {\r\n        this.trendDir = Math.round(Math.random() * 2 - 1); // -1, 0, 1\r\n        this.trendRem = Math.random() * this.maxTrend;\r\n    }\r\n\r\n    next() {\r\n        if (this.trendRem<=0) {\r\n            this.createTrend();\r\n        }\r\n        const step = Math.random() * this.maxStep;\r\n        this.trendRem -= step;\r\n        this.value += step * this.trendDir;\r\n\r\n        //cap at max and reverse trend\r\n        if (this.value >=this.max) {\r\n            this.createTrend();\r\n            this.trendDir = -1;\r\n            this.value -= step;\r\n        }\r\n\r\n        //cap at min and reverse trend\r\n        if (this.value <=this.min) {\r\n            this.createTrend();\r\n            this.trendDir = 1;\r\n            this.value += step;\r\n        }\r\n\r\n        return this.value;\r\n    }\r\n}","import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\n\r\nimport './css/index.css'\r\nimport './css/orthogonal.css'\r\nimport './css/flex.css'\r\n\r\nimport App from './App'\r\n\r\nReactDOM.render(<App />, document.getElementById('root'))\r\n"],"sourceRoot":""}